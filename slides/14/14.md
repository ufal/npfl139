title: NPFL139, Lecture 14
class: title, langtech, cc-by-sa
# Multi-Agent RL,<br>RL from Human Feedback

## Milan Straka

### May 21, 2025

---
section: MARL
class: section
# Multi-Agent Reinforcement Learning

---
# Partially Observable MDPs

![w=51%,f=right](../01/pomdp.svgz)

Recall that a **partially observable Markov decision process** extends the
Markov decision process to a sextuple $(ğ“¢, ğ“, p, Î³, ğ“, o)$, where the MDP
components
- $ğ“¢$ is a set of states,
- $ğ“$ is a set of actions,
- $p(S_{t+1} = s', R_{t+1} = r | S_t = s, A_t = a)$ is a probability that
  action $a âˆˆ ğ“$ will lead from state $s âˆˆ ğ“¢$ to $s' âˆˆ ğ“¢$, producing a **reward** $r âˆˆ â„$,
- $Î³ âˆˆ [0, 1]$ is a **discount factor**,

are extended by:
- $ğ“$ is a set of observations,
- $o(O_{t+1} | S_{t+1}, A_t)$ is an observation model, where observation $O_t$
  is used as agent input instead of the state $S_t$.

---
# Partially Observable Stochastic Game

![w=30%,f=right](marl_posg.svgz)

A **partially observable stochastic game (POSG)** is a 9-tuple
$(ğ“¢, N, \{ğ“^{iâˆˆ[N]}\}, \{Î©^{iâˆˆ[N]}\}, \{R^{iâˆˆ[N]}\}, P, \{O^{iâˆˆ[N]}\}, Ï_0, Î³)$, where

~~~
- $ğ“¢$ is the set of all possible _states_,
~~~
- $N$ is the _number of agents_,
~~~
- $ğ“^{i}$ is the set of all possible _actions_ for agent
  $i$, with $ğ“^Î  â‰ âˆ_i ğ“^i$,
~~~
- $Î©^{i}$ is the set of all possible _observations_ for agent $i$,
~~~
- $P(s_{t+1} âˆˆ ğ“¢ | s_t âˆˆ ğ“¢, â†’a_t âˆˆ ğ“^Î )$ is the _transition model_,
~~~
- $R^{i} : ğ“¢ Ã— ğ“^Î  Ã— ğ“¢ â†’ â„$ is the _reward function_ for agent $i$,
~~~
- $O^{i}(Ï‰^i_{t+1} âˆˆ Î©^i | s_{t+1} âˆˆ ğ“¢, a^i_t âˆˆ ğ“)$ is the _observation model_ for agent $i$,
  a distribution of observing $w^i_{t+1}$ after performing action $a^i_t$
  leading to state $s_{t+1}$,
~~~
- $Ï_{0}$ is the _initial state distribution_,
~~~
- $Î³ âˆˆ [0, 1]$ is a _discount factor_.

---
# Partially Observable Stochastic Game

![w=30%,f=right](marl_posg.svgz)

We denote
- joint actions/policy/observation across all agents as vectors
  $$â†’a â‰ (a^1, â€¦, a^N) âˆˆ ğ“^Î ,$$
~~~
- joint actions/policy/observation for all agents but agent $i$ as
  $$â†’a^{-i} â‰ (a^1, â€¦, a^{i-1}, a^{i+1}, â€¦, a^N),$$

---
# Agent-Environment Cycle Game

However, when actually implementing POSG, various ambiguities exist in the
order of execution. Therefore, **agent-environment cycle game (AECG)** has been
proposed,  
a 12-tuple $(ğ“¢, N, \{ğ“^{iâˆˆ[N]}\}, \{Î©^{iâˆˆ[N]}\}, \{R^{iâˆˆ[N]}\}, \{T^{iâˆˆ[N]}\}, P, \{O^{iâˆˆ[N]}\}, Î½, s_0, i_0, Î³)$ where

~~~
- $ğ“¢$ is the set of all possible _states_,
~~~
- $N$ is the _number of agents_, including $0$ for â€œenvironmentâ€ agent; $[N^âˆª] â‰ [N] \cup \{0\}$,
~~~
- $ğ“^{i}$ is the set of all possible _actions_ for agent $i$, with $ğ“^0 â‰ \{âˆ…\}$, $ğ“^âˆª â‰ \bigcup_{iâˆˆ[N^âˆª]} ğ“^i$,
~~~
- $Î©^{i}$ is the set of all possible _observations_ for agent $i$,
~~~
- $T^{i} : ğ“¢ Ã— ğ“^i â†’ ğ“¢$ is the deterministic _transition function_ for agent $i$,
~~~
- $P(s_{t+1} âˆˆ ğ“¢ | s_t âˆˆ ğ“¢)$ is the transition function for the environment,
~~~
- $R^{i}(r^i_{t+1} âˆˆ â„ | s_t âˆˆ ğ“¢, j âˆˆ [N^âˆª], a^j_t âˆˆ ğ“^j, s_{t+1} âˆˆ ğ“¢)$ is the _reward distribution_ for agent $i$,
~~~
- $O^{i}(Ï‰^i_{t+1} âˆˆ Î©^i | s_{t+1} âˆˆ ğ“¢)$ is the _observation model_ for agent $i$,
~~~
- $Î½(j âˆˆ [N^âˆª] | s_t âˆˆ ğ“¢, i âˆˆ [N^âˆª], a^i_t âˆˆ ğ“^i)$ is the _next agent function_,
~~~
- $s_{0} âˆˆ ğ“¢$ is the _initial state_,
~~~
- $i_{0} âˆˆ [N^U]$ is the _initial agent_,
~~~
$\,âˆ™\,\,\,Î³ âˆˆ [0, 1]$ is a _discount factor_.

---
# Agent-Environment Cycle Game

![w=95%,h=center,mw=42%](marl_posg.svgz)![w=95%,h=center,mw=58%](marl_aecg.svgz)

It holds that for every POSG, there is an equivalent AECG, and vice versa.

~~~
- When starting with POSG, a single transition is represented as N+1 steps in
  AECG: first the N agents sequentially act, storing all their actions in the
  state, and then the environment performs the same transition as the POSG.

~~~
- Starting with AECG, we design POSG where the state is a triple _(AECG state,
  actor to act, reward to obtain)_, and every transition is one step from AECG.

---
# Environment Settings

Depending on the reward function, there are several environment settings:

~~~
- **fully cooperative**, when $âˆ€i, âˆ€j: R^i(s_t, â†’a_t, s_{t+1}) = R^j(s_t, â†’a_t, s_{t+1})$;

~~~
- **zero-sum**, when $âˆ‘_{iâˆˆ[N]} R^i(s_t, â†’a_t, s_{t+1}) = 0$.

~~~
Informally, we talk about **cooperative** and **competitive** settings, but we
refrain from defining them exactly (the definitions that we had were incorrect).

---
# The MARL Problem

We define a trajectory $â†’Ï„$ as a sequence of states and actions
$$â†’Ï„ â‰ (s_0, â†’a_0, s_1, â†’a_1, s_2, â€¦),$$
where:
~~~
- $s_0 âˆ¼ Ï_0$,
~~~
- $â†’a_t âˆ¼ â†’Ï€(â‹…|s_t)$,
~~~
- $s_{t+1} â†’ P(â‹…|s_t, â†’a_t)$.

~~~
A return for an agent $i$ and trajectory $â†’Ï„$ is
$$R^i(â†’Ï„) â‰ âˆ‘_{t=0}^{|â†’Ï„|} Î³^t r^i_{t+1}.$$

---
# The MARL Problem

For a given policy $â†’Ï€$, the expected return for agent $i$ is
$$J^i(â†’Ï€) â‰ ğ”¼_{â†’Ï„ âˆ¼ â†’Ï€} \big[R^i(â†’Ï„)\big],$$
~~~
where a probability of a trajetory $â†’Ï„$ is
$$P(â†’Ï„ | â†’Ï€) â‰ Ï_0(s_0) âˆ_{t=0}^{|â†’Ï„|} P(s_{t+1} | s_t, â†’a_t) â†’Ï€(â†’a_t | s_t).$$ 

~~~
For a given joing policy $â†’Ï€^{-i}$, **best response** is
$$Ï€Ì‚^i(â†’Ï€^{-i}) â‰ \argmax_{Ï€_i} J^i(Ï€^i, â†’Ï€^{-i}).$$

---
style: .halftable { display: inline-block; width: 49% } .halftable table {margin: auto; line-height: 1} .halftable th { text-align: center !important }
# The MARL Goal

It is unfortunately not clear what the goal of MARL should be, given that it is
a multi-criterion optimization problem.

~~~
One possibility is to seek for **Nash equilibrium**, which is a joint policy $â†’Ï€_*$
fulfilling
$$âˆ€ i âˆˆ[N], âˆ€ Ï€^i: J^i(â†’Ï€_*) â‰¥ J^i(Ï€^i, â†’Ï€^{-i}_*).$$

~~~
In other words, $Ï€^i_*$ is a best response to $â†’Ï€^{-i}_*$ for all agents $i$.

~~~
A Nash equilibrium exists for any finite game (finite number of players, each
with a finite number of strategies).
~~~
Unfortunately, there can be multiple Nash equilibria with different payoffs
(Nash equilibrium is just a â€œlocalâ€ optimum).

~~~
<div class="halftable">

- Stag hunt

| A\B | Stag | Rabbit |
|:---|:--:|:--:|
| Stag | 2\2 | 0\1 |
| Rabbit | 1\0 | 1\1 |

</div>
~~~
<div class="halftable">

- Prisoner's dilemma

| A\B | Stay silent | Testify |
|:---|:--:|:--:|
| Stay silent | -1\\-1 | -3\\0 |
| Testify | 0\\-3 | -2\\-2 |

</div>

---
section: MARL Schemes
class: section
# MARL Training Schemes

---
# MARL Training Schemes

## Centralized Scheme

![w=50%,h=center](marl_scheme_centralized.svgz)

A joint model for all agents, a single critic.

---
# MARL Training Schemes

## Concurrent/Parameter-Sharing Scheme

![w=80%,h=center,mw=50%](marl_scheme_concurrent.svgz)![w=90%,h=center,mw=50%](marl_scheme_parameter_sharing.svgz)

Each agent is trained independently. When the agents are homogenous, their
models can be optionally shared (the _parameter-sharing scheme_).

However, the environment is then non-stationary, and using a replay buffer is
problematic because of changing policies of other agents.

---
# MARL Training Schemes

## Centralized Training with Decentralized Execution

![w=50%,h=center](marl_scheme_ctde.svgz)

Quite a common model, where the agents are independent, but the critics get
the observations and actions of all agents.

---
section: MARL Algos
class: section
# MARL Algorithms

---
# Multi-Agent Deep Deterministic Policy Gradient

![w=100%,v=middle](maddpg_scheme.svgz)

---
# Multi-Agent Deep Deterministic Policy Gradient

![w=71%,f=left,h=center,mw=65%](maddpg_algorithm.svgz)

~~~
Alternatively, in multi-agent settings, in some experiments it was beneficial
to estimate the gradient for the policy update using the current policy instead
of the action from the replay buffer; if the line 14 is changed to
$$âˆ‡^i_{â†’Î¸} \frac{1}{|B|} âˆ‘_{â†’Ï‰} Q^i_Ï†\big(â†’Ï‰, â†’Î¼_{â†’Î¸}(â†’Ï‰)\big),$$
we talk about _Soft MADDPG_.

---
# Multi-Agent Twin Delayed DDPG

![w=100%,v=middle](matd3_scheme.svgz)

---
# Multi-Agent Twin Delayed DDPG

![w=60%,f=left,h=center,mw=65%](matd3_algorithm.svgz)

~~~
We can again consider a _Soft MATD3_ variant.

~~~
Furthermore, we can also use the minimum of both critics during
policy update (shown to be beneficial by DDPG++ and SAC). The resulting
algorithm is called _(Soft) MATD4_.

---
section: MARL Eval
class: section
# MARL Evaluation
---

# MARL Evaluation, Simple Target

![w=60%](marl_simple_target.svgz)![w=40%](marl_simple_collect.svgz)

Reward is given for touching a landmark, and for unoccupied landmarks
also for distance of the nearest agent (orignally any agent, but easier
variant is an agent not occupying a landmark).

~~~
The agents have non-negligible size and get negative reward for colliding.

~~~
Actions can be discrete (âˆ…, â†, â†’, â†‘, â†“; ST Gumbel-softmax is used) or continuous.

~~~
In the _Simple Collect_ variant, the targets disappear after being occupied for
some time, and a new one appears on a random location.

---
# MARL Evaluation, Simple Target, Continuous Actions

![w=71%,h=center](marl_simple_target_continuous_graph.svgz)

---
# MARL Evaluation, Simple Target, Continuous Actions

![w=59%,h=center](marl_simple_target_continuous_table.svgz)

---
# MARL Evaluation, Simple Target, Discrete Actions

![w=71%,h=center](marl_simple_target_discrete_graph.svgz)

---
# MARL Evaluation, Simple Target, Discrete Actions

![w=59%,h=center](marl_simple_target_discrete_table.svgz)

---
# MARL Evaluation, Simple Confuse

![w=50%,h=center](marl_simple_confuse.svgz)

Some number of cooperaing agents gets rewarded based on the minimum distance of
any agent to the target landmark; but are penalized based on the distance
of a single adversary to the target landmark.

~~~
The adversary gets rewarded based on its distance to the target landmark;
however, it does not know which landmark is the target one.

~~~
Actions can be again either discrete or continuous.

---
# MARL Evaluation, Simple Confuse, Continuous Actions

![w=71%,h=center](marl_simple_confuse_continuous_graph.svgz)

---
# MARL Evaluation, Simple Confuse, Continuous Actions

![w=59%,h=center](marl_simple_confuse_continuous_table.svgz)

---
# MARL Evaluation, Simple Confuse, Discrete Actions

![w=71%,h=center](marl_simple_confuse_discrete_graph.svgz)

---
# MARL Evaluation, Simple Confuse, Discrete Actions

![w=59%,h=center](marl_simple_confuse_discrete_table.svgz)

---
section: HideAndSeek
# Multi-Agent Hide-and-Seek

As another example, consider https://openai.com/blog/emergent-tool-use/.

Here the agents are trained in the centralized training with decentralized
execution settings, using the PPO algorithm.

---
section: RLHF
class: section
# Reinforcement Learning with Human Feedback

---
# Reinforcement Learning with Human Feedback

Let us assume our goal is to train a robot to cook eggs.

~~~
For such complex tasks, there might not be suitable reward functions available,
and implementing it manually might be difficult or infeasible.

~~~
If we have demonstrations for the seeked behavior, we might use inverse
reinforcement learning or imitation learning, but some behaviors might be
difficult to demonstrate (like controlling a robot with many degrees of
freedom).

---
# Reinforcement Learning with Human Feedback

![w=50%,f=right](rlhf_schema.svgz)

A possible approach in such a case is to use **reinforcement learning with human
feedback**, proposed in a 2017 paper.

~~~
Because human feedback is costly, using as little as feedback is desirable.
Therefore, the authors propose to use the feedback to train a reward function,
which can then be used by classical RL algorithms.

~~~
A practical approach is for the human raters to
_compare two video clips of agent's behavior_.
~~~
- Comparing two videos was found out to be considerably easier than providing
  absolute numerical score.
~~~
- Rating videos is nearly as fast as comparing individual states, but
  significantly more helpful.

---
# General Setting

We consider a partially observable MDP, where in time $t$ agent obtains an
observation $o_t$ and produces an action $a_t$.

~~~
In the traditional RL setting, the environment would also produce the reward
$r_t$; we will instead predict a reward $rÌ‚(o_t, a_t)$.

~~~
A **trajectory segment** is a sequence of observations and actions
$$Ïƒ = ((o_0, a_0), (o_1, a_1), â€¦, (o_{k-1}, a_{k-1})).$$

~~~
We write $Ïƒ^1 â‰» Ïƒ^2$ to indicate that a human rater preferred trajectory $Ïƒ^1$
over trajectory $Ïƒ^2$.

---
# Reinforcement Learning with Human Feedback

We maintain two models:
~~~
- the policy $Ï€: ğ“ â†’ ğ“$, and
~~~
- the reward function estimate $rÌ‚: ğ“ Ã— ğ“ â†’ â„$.

~~~
The models are updated by three asynchronously running processes:
~~~
1. The policy $Ï€$ interacts with the environment, obtaining a set of
   trajectories $\{Ï„^1, â€¦, Ï„^i\}$.

   The parameters of $Ï€$ are updated using a traditional RL algorithm
   utilizing the estimated reward $rÌ‚$.

~~~
2. A pair of segments $(Ïƒ^1, Ïƒ^2)$ from trajectories $\{Ï„^1, â€¦, Ï„^i\}$
   generated in step 1 is selected and sent to human rater for evaluation.

~~~
3. The reward estimate $rÌ‚$ is trained using supervised learning to fit
   the comparisons selected by the annotators so far.

---
# Reinforcement Learning with Human Feedback

## Optimizing the Policy

During policy optimization, we can utilize the usual RL algorithms.
~~~
The main difference is that the rewards are non-stationary; therefore,
policy-gradient methods are preferred.

~~~
During training we normalize $rÌ‚$ to have zero mean and constant standard
deviation (theÂ absolute values of the rewards are undetermined in our model).

~~~
## Preference Collection

The visualization given to a rater is a video between 1 and 2 seconds long.
The rater indicate which of the segments they prefer, whether the segments
are equally good, of that they were not able to compare the two segments.

~~~
All human judgements are stored in a dataset $ğ““$ of triples $(Ïƒ^1, Ïƒ^2, â†’Î¼)$,
where $Ïƒ^1, Ïƒ^2$ are the compared segments and $â†’Î¼$ is a distribution over ${1, 2}$
indicating which segment was deemed better. The $â†’Î¼$ is either one hot
distribution when a single segment was preferred, or a uniform distribution when
a rater annotated both videos as being comparable.

---
style: .katex-display { margin: .8em 0 }
# Reward Function Fitting

We follow the Bradley-Terry model, which is a binary probability model for
the outcome of pairwise comparisons between players

$$P(\underbrace{i > j}_{\kern-.4emâ€œi\textrm{~beats~}jâ€\kern-.4em}) = \frac{p_i}{p_i + p_j},$$

where $p_i$ is a positive real-valued score assigned to player $i$.

~~~
There are many possible parametrizations, Bradley and Terry used $p_i
= e^{Î²_i}$, in which case
$$P(i > j) = \frac{e^{Î²_i}}{e^{Î²_i} + e^{Î²_j}} = \frac{1}{1 + e^{Î²_j-Î²_i}} = Ïƒ(Î²_i - Î²_j).$$

~~~
Note that with a scaling factor 400 and base 10, this is equivalent to the Elo
rating system with Elo ratings $R_i$ and $R_j$:
$$P(i > j) = \frac{1}{1 + 10^{(R_j-R_i)/400}} = Ïƒ\big((R_i-R_j)\tfrac{\log 10}{400}\big).$$

---
style: .katex-display { margin: .8em 0 }
# Reward Function Fitting

In our case, we assume that
$$PÌ‚(Ïƒ^1 â‰» Ïƒ^2)
  = \frac{\exp âˆ‘rÌ‚(o_t^1, a_t^1)}{\exp âˆ‘rÌ‚(o_t^1, a_t^1) + \exp âˆ‘rÌ‚(o_t^2, a_t^2)}
  = \textstyle Ïƒ\big(âˆ‘rÌ‚(o_t^1, a_t^1) - âˆ‘rÌ‚(o_t^2, a_t^2)\big).$$

~~~
To fit this model we minimize the cross-entropy between the observed
distribution of human rating $â†’Î¼$ and these predictions:
$$ğ“› = -ğ”¼_{(Ïƒ^1, Ïƒ^2, â†’Î¼) âˆ¼ ğ““} \big[Î¼_1 \log PÌ‚(Ïƒ^1 â‰» Ïƒ^2) + Î¼_2 \log PÌ‚(Ïƒ^2 â‰» Ïƒ^1)\big].$$

~~~
The authors mention several tricks:
~~~
- A whole ensemble of predictors are trained, each using randomly sampled |ğ““|
  examples (with replacement) from ğ““. The overall $rÌ‚$ is then defined by first
  independently normalizing each of the predictors and then averaging the
  results.
~~~
- A fraction $1/e$ of the data is used as development data, and strength of
  $L^2$-regularization is set so that the development loss is between 1.1 and
  1.5 of the training loss.
~~~
- In the definition of $PÌ‚$, we assume there is a 10% chance of uniform random
  outcome.

---
# Reward Function Fitting

To select the queries for the raters, we
~~~
- sample a large amount of pairs of trajectory segments of length $k$,
~~~
- perform prediction on each pair using all the predictors in our ensemble,
~~~
- choose the pairs with the highest variance in the predictions, which
  approximates the largest uncertainty.

---
# Experiments

In first experiments, the authors attempted to solve existing RL benchmarks
(Atari, MuJoCo) without observing the true rewards, using human feedback
instead.

~~~
For comparison, synthetic feedback (instead of human feedback) was also
considered in these tasks, where $PÌ‚(Ïƒ^1 â‰» Ïƒ^2)$ is defined by using the real
reward of the trajectory segments.

~~~
For MuJoCo, 700 human ratings were used; for Atari, 5.5k queries were sent to
human raters.
~~~
Overall the ratings took between 30 minutes and 5 hours for every experiment.

---
# Experiments: MuJoCo

![w=67%,h=center](rlhf_mujoco_results.png)

---
# Experiments: Atari

![w=76%,h=center](rlhf_atari_results.svgz)

---
# Experiments: Novel Behavior

The authors also demonstrated the effectiveness of human feedback in tasks
without available reward functions:

<iframe src="https://drive.google.com/file/d/0BwcFziBYuA8RdHdrY1p3OHEwTVU/preview?resourcekey=0-mr-Z4KuKyVHyKXbaWwGC0g" width="450" height="450" allow="autoplay" style="display: block; margin: auto; float: right"></iframe>

~~~
- the Hopper robot was trained to perform a backflip using 900 queries in less
  than an hour;

~~~
- the Half-Cheetah was trained to move while standing on just one leg via 800
  queries;

~~~
- in Enduro, the agent was trained to keep the same speed as other cars using
  1Â 300 queries.

---
# Ablations: MuJoCo

![w=67%,f=right](rlhf_mujoco_ablations.png)

- random queries: queries picked uniformly at random instead of according to
  variance of predictions;

- no ensemble: a single predictor is trained; random queries are implied;

- no online queries: all queries generated at the beginning of the training;

- no regularization: w/o validation $L^2$ condition;

- no segments: rate only images, not videos;

- target: instead of fitting $rÌ‚$ using comparison, we fit given real $r$ using MSE.

---
# Ablations: Atari

![w=82%,h=center](rlhf_atari_ablations.svgz)

---
# Instructions: MuJoCo

- Look at the clips and select the one in which better things happen. Only
  decide on events you actually witness in the clip.

- Hereâ€™s a guide on what constitutes good and bad behavior in each specific
  domain:
  - **Hopper**: the â€œcenterâ€ of the robot is the joint closest to the pointy end.
    The first priority is for the center of the robot to move to the right
    (moving to the left is worse than not moving at all). If the two robots are
    roughly tied on this metric, then the tiebreaker is how high the center is.

  - **Cheetah**: the robot should move to the right as fast as possible.

  - **Pendulum**: the pendulum should be pointing approximately up. There will be
    a lot of ties where the pendulum has fallen and a lot of â€œcanâ€™t tellsâ€ where
    it is off the side of the screen. If you can see one pendulum and it hasnâ€™t
    fallen down, thatâ€™s better than being unable to see the other pendulum.

- If both clips look about the same to you, then click â€œtieâ€. If you donâ€™t
  understand whatâ€™s going on in the clip or find it hard to evaluate, then click
  â€œcanâ€™t tellâ€.

---
# Instructions: Atari

- First play the game yourself for 5 minutes. Before providing feedback to the
  AI, play the game yourself for a five minutes to get a sense of how it works.
  Itâ€™s often hard to tell what the game is about just by looking at short clips,
  especially if youâ€™ve never played it before.

- Look at the clips and select the one in which better things happen. For
  example, if the left clip shows the AI shooting an enemy ship while the right
  clip shows it being shot by an enemy ship, then better things happen in the
  left clip and thus the left clip is better. Only decide on actions you
  actually witness in the clip.

- Hereâ€™s a guide on what constitutes good and bad play in each specific game:
  - **Breakout**: hit the ball with the paddle, break the colored blocks, and
    donâ€™t let the ball fall off the bottom of the screen

  - **Pong**: knock the ball past the opponentâ€™s orange paddle on the left
    (good), and donâ€™t let it go past your green paddle on the right (bad)

- Donâ€™t worry about how the agent got into the situation it is in (for instance,
  it doesnâ€™t matter if one agent has more lives, or is now on a more advanced
  level); just focus on what happens in the clip itself.

---
# Learning to Summarize from Human Feedback

RLHF was used to improve summarization in a 2020 paper.

~~~
The Reddit TL;DR dataset and CNN/Daily Mail dataset were utilized.
The Reddit TL;DR contains 3M posts from reddit.com with summaries written by
original posters; the authors filtered the data (including requiring the
summaries to be between 24 and 48 tokens) and kept 123Â 169 posts with ~5%
kept as a validation set.

~~~
The following models were considered:

- **Pretrained models**: Pretrained LLMs, with several high-quality examples in
  the prompt.

~~~
- **Supervised baselines**: Finetuned variants of the above models trying to
  predict the summaries from the filtered TL;DR dataset.

~~~
- **Reward models**: Starting from the supervised baselines, RLHF was applied.
  A new output linear layer producing a single scalar was added to the model
  and the model was trained to predict rating $r_{â†’Î¸}(x, y_i)$ that corresponds
  the most to the observed ratings according to the Bradley-Terry model:

  $$ğ“› = -ğ”¼_{(x, y_0, y_1, i) âˆ¼ ğ““} \big[\log(Ïƒ(r_{â†’Î¸}(x, y_i) - r_{â†’Î¸}(x, y_{1-i})))\big].$$

---
# Learning to Summarize from Human Feedback

![w=82%,h=center](summhf_overview.svgz)

---
# Learning to Summarize from Human Feedback

The human feedback policies are then trained using the reward model.

Generating the entire summary is considered a sequence of actions, each
being a generation of a single BPE token, and the PPO algorithm is used
with the following reward:

$$R(x, y) â‰ r_{â†’Î¸}(x, y) - Î² \log \big[Ï€^\textrm{RL}_{â†’Ï†}(y|x) / Ï€^\textrm{SFT}(y|x)\big],$$

~~~
where the per-token KL term serves two purposed:
~~~
- it acts as an entropy bonus to avoid collapsing to a single node;
~~~
- it ensures the policy does not learn to produce completely different outputs
  too different from those the reward model saw during reward fitting.

---
# Learning to Summarize from Human Feedback

![w=75%,h=center](summhf_results_tldr.svgz)

In total, 64Â 832 ratings were collected, and they were publicly released.

---
# Learning to Summarize from Human Feedback

![w=95%,h=center](summhf_results_cnndm.svgz)

---
# Learning to Summarize from Human Feedback

![w=92%,mw=49%,h=center](summhf_data_model_sizes.svgz)
~~~
![w=94%,mw=49%,h=center](summhf_kl.svgz)

---
# Training LMs to Follow Instructions with Human Feedback

In 2022, InstructGPT (ChatGPT predecessor) was trained to follow instructions
using human feedback.

~~~
![w=72%,h=center](../01/rlhf_overview.svgz)

---
# Training LMs to Follow Instructions with Human Feedback

The same Bradley-Terry model is used to train the reward function.

~~~
To speed up comparison collection, the authors presented the labelers between
$K=4$ and $K=9$ responses to rank, producing $\binom{K}{2}$ comparisons for
every prompt.

~~~
However, the comparisons in a single prompt are very correlated, so sampling
them randomly during an epoch caused the model to overfit. Instead, all
$\binom{K}{2}$ comparisons were used in a single batch, which is also more
efficient (only $K$ passes of the reward model, compared to
$\binom{K}{2}$ passes).

~~~
The loss function for the reward model is analogous to before:

$$ğ“› = -\frac{1}{\binom{K}{2}}ğ”¼_{(x, y_w, y_l) âˆ¼ ğ““} \big[\log(Ïƒ(r_{â†’Î¸}(x, y_w) - r_{â†’Î¸}(x, y_l)))\big].$$

---
# Training LMs to Follow Instructions with Human Feedback

The SFT models are finetuned using the trained reward model again using the PPO
algorithm, employing the following objective:

$$ğ”¼_{(x, y) âˆ¼ ğ““_{Ï€_{â†’Ï†}^\textrm{RL}}} \big[ r_{â†’Î¸}(x, y) - Î² \log \big(Ï€^\textrm{RL}_{â†’Ï†}(y|x) / Ï€^\textrm{SFT}(y|x)\big) \big].$$

~~~
The authors also proposed a variant called PPO-ptx., which also includes an
additional supervised term in the objective:

$$ğ”¼_{(x, y) âˆ¼ ğ““_{Ï€_{â†’Ï†}^\textrm{RL}}} \big[ r_{â†’Î¸}(x, y) - Î² \log \big(Ï€^\textrm{RL}_{â†’Ï†}(y|x) / Ï€^\textrm{SFT}(y|x)\big) \big] + Î³ ğ”¼_{x âˆ¼ ğ““_\textrm{pretrain}}\big[\log(Ï€_{â†’Ï†}^\textrm{RL}(x))\big].$$

---
# Training LMs to Follow Instructions with Human Feedback

![w=84%,h=center](instructgpt_results.svgz)

---
# Training LMs to Follow Instructions with Human Feedback

![w=51%,h=center](instructgpt_winrates.svgz)

---
# Training LMs to Follow Instructions with Human Feedback

![w=100%,h=center](instructgpt_metadata.svgz)

---
# Training LMs to Follow Instructions with Human Feedback

![w=40%,h=center](instructgpt_public_datasets_zeroshot.svgz)

---
# Training LMs to Follow Instructions with Human Feedback

![w=42%,h=center](instructgpt_public_datasets_fewshot.svgz)

---
section: DPO
class: section
# Direct Preference Optimization

---
# Direct Preference Optimization

![w=100%](dpo_overview.svgz)

---
# Direct Preference Optimization

![w=100%,h=center](dpo_results.svgz)

---
# Direct Preference Optimization

![w=100%,h=center](dpo_win_rates.svgz)
